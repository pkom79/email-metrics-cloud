/**
 * Revenue Tier Scoring
 * 
 * Two scoring approaches:
 * 1. Auto-calibrated tiers (relative to account size) - for comparing steps within an account
 * 2. Standalone annualized revenue (absolute) - for assessing business value independent of context
 * 
 * A step generating $12k/month is worth $150k/year regardless of what other steps do.
 */

/**
 * Default revenue tier thresholds for a ~$100k account (baseline).
 * These get scaled by the account's actual revenue.
 */
const DEFAULT_TIERS = [
    { threshold: 50000, points: 35 },  // $50k+ → max points
    { threshold: 25000, points: 30 },
    { threshold: 10000, points: 25 },
    { threshold: 5000, points: 20 },
    { threshold: 2000, points: 15 },
    { threshold: 500, points: 10 },
    { threshold: 0, points: 5 },       // Any revenue → minimum points
];

/**
 * Baseline account revenue for tier scaling.
 * Accounts with this revenue use the default thresholds.
 */
const BASELINE_ACCOUNT_REVENUE = 100_000;

/**
 * Minimum multiplier to prevent thresholds from becoming too small
 */
const MIN_MULTIPLIER = 0.1;

/**
 * Maximum multiplier to prevent thresholds from becoming absurdly high
 */
const MAX_MULTIPLIER = 10;

/**
 * Calculate the tier multiplier based on account's total flow revenue.
 * 
 * @param accountFlowRevenue - Total revenue from all flows in the account for the date range
 * @returns Multiplier for revenue tier thresholds
 */
export function calculateTierMultiplier(accountFlowRevenue: number): number {
    if (accountFlowRevenue <= 0) return MIN_MULTIPLIER;
    
    const rawMultiplier = accountFlowRevenue / BASELINE_ACCOUNT_REVENUE;
    
    return Math.max(MIN_MULTIPLIER, Math.min(MAX_MULTIPLIER, rawMultiplier));
}

/**
 * Get the calibrated revenue tiers for an account.
 * 
 * @param accountFlowRevenue - Total revenue from all flows in the account
 * @returns Array of tier thresholds scaled to the account
 */
export function getCalibratedTiers(accountFlowRevenue: number): Array<{ threshold: number; points: number }> {
    const multiplier = calculateTierMultiplier(accountFlowRevenue);
    
    return DEFAULT_TIERS.map(tier => ({
        threshold: tier.threshold * multiplier,
        points: tier.points
    }));
}

/**
 * Calculate absolute revenue points for a step (0-35 max).
 * Rewards steps that generate real dollars, scaled to the account's size.
 * 
 * @param stepRevenue - Revenue generated by this step in the date range
 * @param accountFlowRevenue - Total revenue from all flows in the account
 * @returns Points from 0-35 based on absolute revenue
 */
export function getAbsoluteRevenuePoints(
    stepRevenue: number,
    accountFlowRevenue: number
): { points: number; tier: number; threshold: number } {
    const tiers = getCalibratedTiers(accountFlowRevenue);
    
    for (let i = 0; i < tiers.length; i++) {
        if (stepRevenue >= tiers[i].threshold) {
            return {
                points: tiers[i].points,
                tier: i + 1,
                threshold: tiers[i].threshold
            };
        }
    }
    
    // Should never reach here, but fallback to minimum
    return { points: 5, tier: tiers.length, threshold: 0 };
}

/**
 * Get a human-readable description of the revenue tier.
 */
export function getRevenueTierDescription(tier: number): string {
    switch (tier) {
        case 1: return 'Exceptional revenue';
        case 2: return 'Strong revenue';
        case 3: return 'Good revenue';
        case 4: return 'Moderate revenue';
        case 5: return 'Low revenue';
        case 6: return 'Minimal revenue';
        default: return 'Very low revenue';
    }
}

/**
 * Format revenue thresholds for display.
 * Uses account-calibrated thresholds to show contextual targets.
 */
export function formatThresholdForDisplay(threshold: number): string {
    if (threshold >= 1000) {
        return `$${(threshold / 1000).toFixed(threshold >= 10000 ? 0 : 1)}k`;
    }
    return `$${threshold.toFixed(0)}`;
}

/**
 * Standalone Annualized Revenue Tiers
 * 
 * These tiers score revenue based on its annualized value, independent of account size.
 * A step generating $12,593/month = $151k/year is valuable regardless of context.
 * 
 * Tiers based on annualized revenue:
 * $150k+/yr → 35pts (exceptional)
 * $100k+/yr → 30pts (strong)
 * $50k+/yr  → 25pts (good)
 * $25k+/yr  → 20pts (moderate)
 * $10k+/yr  → 15pts (emerging)
 * $5k+/yr   → 10pts (minimal)
 * Any       → 5pts  (baseline)
 */
const STANDALONE_ANNUALIZED_TIERS = [
    { annualThreshold: 150000, points: 35, label: 'Exceptional' },
    { annualThreshold: 100000, points: 30, label: 'Strong' },
    { annualThreshold: 50000, points: 25, label: 'Good' },
    { annualThreshold: 25000, points: 20, label: 'Moderate' },
    { annualThreshold: 10000, points: 15, label: 'Emerging' },
    { annualThreshold: 5000, points: 10, label: 'Minimal' },
    { annualThreshold: 0, points: 5, label: 'Baseline' },
];

/**
 * Calculate standalone revenue score based on annualized value.
 * This is INDEPENDENT of account size - a $150k/yr step is exceptional everywhere.
 * 
 * @param stepRevenue - Revenue generated by this step in the date range
 * @param daysInRange - Number of days in the date range (for annualization)
 * @returns Points from 0-35 and tier info
 */
export function getStandaloneRevenueScore(
    stepRevenue: number,
    daysInRange: number
): {
    points: number;
    tier: number;
    tierLabel: string;
    annualizedRevenue: number;
    monthlyRevenue: number;
} {
    // Annualize based on actual date range (minimum 30 days to avoid over-extrapolation)
    const effectiveDays = Math.max(30, daysInRange);
    const annualizationFactor = 365 / effectiveDays;
    const annualizedRevenue = stepRevenue * annualizationFactor;
    const monthlyRevenue = annualizedRevenue / 12;
    
    for (let i = 0; i < STANDALONE_ANNUALIZED_TIERS.length; i++) {
        const tier = STANDALONE_ANNUALIZED_TIERS[i];
        if (annualizedRevenue >= tier.annualThreshold) {
            return {
                points: tier.points,
                tier: i + 1,
                tierLabel: tier.label,
                annualizedRevenue,
                monthlyRevenue
            };
        }
    }
    
    return {
        points: 5,
        tier: STANDALONE_ANNUALIZED_TIERS.length,
        tierLabel: 'Baseline',
        annualizedRevenue,
        monthlyRevenue
    };
}

/**
 * Format annualized revenue for display.
 */
export function formatAnnualizedRevenue(annual: number): string {
    if (annual >= 1000000) {
        return `$${(annual / 1000000).toFixed(1)}M/yr`;
    }
    if (annual >= 1000) {
        return `$${(annual / 1000).toFixed(0)}k/yr`;
    }
    return `$${annual.toFixed(0)}/yr`;
}

/**
 * Get description of what the annualized revenue means for business value.
 */
export function getStandaloneRevenueDescription(tierLabel: string, monthlyRevenue: number): string {
    const monthly = monthlyRevenue >= 1000 
        ? `$${(monthlyRevenue / 1000).toFixed(1)}k` 
        : `$${monthlyRevenue.toFixed(0)}`;
    
    switch (tierLabel) {
        case 'Exceptional':
            return `This step generates ~${monthly}/month—a significant revenue driver worth protecting and scaling.`;
        case 'Strong':
            return `This step generates ~${monthly}/month—strong business value worth optimizing.`;
        case 'Good':
            return `This step generates ~${monthly}/month—solid contribution to the business.`;
        case 'Moderate':
            return `This step generates ~${monthly}/month—meaningful but has growth potential.`;
        case 'Emerging':
            return `This step generates ~${monthly}/month—room to grow with optimization.`;
        case 'Minimal':
            return `This step generates ~${monthly}/month—consider testing improvements.`;
        default:
            return `This step is generating minimal revenue.`;
    }
}

/**
 * Calculate the money pillar score combining efficiency (Revenue Index) and absolute revenue.
 * Total max: 70 points (35 for RI + 35 for absolute revenue)
 * 
 * @param revenuePerEmail - RPE for this step
 * @param medianRPE - Median RPE across all steps in the flow
 * @param stepRevenue - Total revenue from this step
 * @param accountFlowRevenue - Total account flow revenue for calibration
 * @returns Combined money pillar points and breakdown
 */
export function calculateMoneyPillarScore(
    revenuePerEmail: number,
    medianRPE: number,
    stepRevenue: number,
    accountFlowRevenue: number
): {
    totalPoints: number;
    riPoints: number;
    riValue: number;
    absoluteRevenuePoints: number;
    absoluteRevenueTier: number;
} {
    // Revenue Index (efficiency): 0-35 points
    // RI = RPE / medianRPE, clipped to [0, 2.0], then scaled to 35 points
    const riRaw = medianRPE > 0 ? revenuePerEmail / medianRPE : 0;
    const riClipped = Math.max(0, Math.min(2.0, riRaw));
    const riPoints = 35 * (riClipped / 2);
    
    // Absolute revenue: 0-35 points (calibrated to account size)
    const absoluteResult = getAbsoluteRevenuePoints(stepRevenue, accountFlowRevenue);
    
    return {
        totalPoints: Math.min(70, riPoints + absoluteResult.points),
        riPoints,
        riValue: riClipped,
        absoluteRevenuePoints: absoluteResult.points,
        absoluteRevenueTier: absoluteResult.tier
    };
}

/**
 * Calculate the money pillar score using STANDALONE annualized revenue.
 * This version is independent of other flows/steps - values revenue at face value.
 * 
 * Total max: 70 points (35 for RI + 35 for standalone annualized revenue)
 * 
 * @param revenuePerEmail - RPE for this step
 * @param medianRPE - Median RPE across all steps in the flow
 * @param stepRevenue - Total revenue from this step in the date range
 * @param daysInRange - Number of days in the date range (for annualization)
 * @returns Combined money pillar points and breakdown
 */
export function calculateMoneyPillarScoreStandalone(
    revenuePerEmail: number,
    medianRPE: number,
    stepRevenue: number,
    daysInRange: number
): {
    totalPoints: number;
    riPoints: number;
    riValue: number;
    standalonePoints: number;
    standaloneTier: number;
    standaloneTierLabel: string;
    annualizedRevenue: number;
    monthlyRevenue: number;
} {
    // Revenue Index (efficiency): 0-35 points
    // RI = RPE / medianRPE, clipped to [0, 2.0], then scaled to 35 points
    const riRaw = medianRPE > 0 ? revenuePerEmail / medianRPE : 0;
    const riClipped = Math.max(0, Math.min(2.0, riRaw));
    const riPoints = 35 * (riClipped / 2);
    
    // Standalone annualized revenue: 0-35 points (independent of account size)
    const standaloneResult = getStandaloneRevenueScore(stepRevenue, daysInRange);
    
    return {
        totalPoints: Math.min(70, riPoints + standaloneResult.points),
        riPoints,
        riValue: riClipped,
        standalonePoints: standaloneResult.points,
        standaloneTier: standaloneResult.tier,
        standaloneTierLabel: standaloneResult.tierLabel,
        annualizedRevenue: standaloneResult.annualizedRevenue,
        monthlyRevenue: standaloneResult.monthlyRevenue
    };
}
